<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
<meta name="viewport" content="initial-scale=1.0, user-scalable=yes"/>
<link rel="stylesheet" href="resources/web/style.css">
<link rel="stylesheet" href="resources/web/leaflet-1.7.1.css"/>
  <!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="resources/web/leaflet-1.7.1.js"></script>

<script type="text/javascript" src="qrc:///qtwebchannel/qwebchannel.js"></script>
</head>
<body>

 <div id="map"></div>

 <script>

  new QWebChannel(qt.webChannelTransport, function (channel) {
      var map_view = channel.objects.map_view;
      var modules_geojson = null;
      var data_prev = null;
      var annotation_data = null;
      var map = L.map('map');
      L.tileLayer(
          'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          maxZoom: 22,
          maxNativeZoom: 19,
          zoom: 18,
          zoomSnap: 0,
          zoomDelta: 0.5,
          wheelPxPerZoomLevel: 70,
      }).addTo(map);

      resetMap();

      function resetMap() {
        map.setView(new L.LatLng(48.1, 11.5), 8);
      }

      function drawData(data, fit_map_bounds) {
        // do not redraw if data has not changed
        if (data == data_prev) { 
          map_view.printObj(JSON.stringify("Data has not changed, not redrawing"));
          return; 
        }
        map_view.printObj(JSON.stringify("Data changed, redrawing"));
        data_prev = data;

        js_data = JSON.parse(data);
        if (js_data.data.length === 0) { return; }

        var active_module;

        // callback when module is clicked
        function moduleClicked(e) {
          var layer = e.target;
          const track_id = layer.feature.properties.track_id;
          map_view.printObj(JSON.stringify("Clicked on module " + track_id));

          // highlight active module
          if (active_module) {
            modules_geojson.resetStyle(active_module);
          }
          active_module = layer;
          layer.setStyle({
              color: 'red',
              fillColor: 'red'
          });

          draw_defect_annotations();
          //loadAnnotatedFaults(track_id);
          //loadPatches(track_id);

          // update source frame and patches
          map_view.update_images(JSON.stringify(track_id));
        }

        function onEachFeature(feature, layer) {
          layer.on({
              click: moduleClicked
          });
        }

        // clear map
        if (modules_geojson !== null) {
          map_view.printObj(JSON.stringify("Deleting modules_geojson"));
          map.removeLayer(modules_geojson);
        }

        // draw PV modules on map
        modules_geojson = L.geoJSON(js_data.data, {
          onEachFeature: onEachFeature,
          filter: function(feature, layer) {
            return (feature.geometry.type == "Polygon");
          },
          style: function(feature) {
            var color = js_data.colors[feature.properties.track_id];
            return {
              "color": color,
              "fillColor": color,
              "weight": 1,
              "opacity": 1,
              "fill": true,
              "fillOpacity": 0.5
            };
          }
        }).addTo(map);

        draw_defect_annotations();

        if (fit_map_bounds) {
          map.fitBounds(modules_geojson.getBounds());
        }
      }

      function reset_defect_annotations() {
        modules_geojson.eachLayer(function (layer) {
          var fill_color = layer.options.fillColor;
          layer.setStyle({color: fill_color, fillColor: fill_color, weight: 1});
        });
      }

      function draw_defect_annotations() {
        if (annotation_data === null) { 
          reset_defect_annotations();
          return;
        }
        map_view.printObj(JSON.stringify("Drawing defect annotations."));
        modules_geojson.eachLayer(function (layer) {
          var track_id = layer.feature.properties.track_id;
          var defects = annotation_data[track_id];          
          if (defects.length > 0) {
            var fill_color = layer.options.fillColor;
            layer.setStyle({color: 'red', fillColor: fill_color, weight: 3});
          }
          // reset style
          else {
            var fill_color = layer.options.fillColor;
            layer.setStyle({color: fill_color, fillColor: fill_color, weight: 1});
          }
        });
      }

      // wait for modules to be updated
      map_view.dataset_changed.connect(function(fit_map_bounds) {
          map_view.printObj(JSON.stringify("Loading dataset in JS."));

          // draw modules + data
          map_view.get_data(function(data) {
            drawData(data, fit_map_bounds);
          });
      });

      map_view.dataset_closed.connect(function() {
        map_view.printObj(JSON.stringify("Closing dataset, clearing data in JS"));
          map.removeLayer(modules_geojson);
          modules_geojson = null;
          data_prev = null;
          resetMap();
      });

      // load annotation data whenever annotations change
      map_view.annotation_data_changed.connect(function() {
        map_view.get_annotation_data(function(data) {
          annotation_data = JSON.parse(data);
          draw_defect_annotations();
        });        
      });
  });
 </script>

</body>
</html>
